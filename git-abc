#!/bin/bash
#
# git-abc - A Backporter's Companion (ABC)
#           Find and manage backport candidates
#
# Copyright (c) 2017 Red Hat, Inc.
#
# Authors:
#   Andrew Jones <drjones@redhat.com>
#
# This work is licensed under the MIT License. Please see the LICENSE
# file or http://opensource.org/licenses/MIT.
#

USAGE="usage: git-abc <command> [<options>]"
GIT_DIR=$(git rev-parse --git-dir)

ABC_DEFAULT_SHOULD_HIGHLIGHT="%s:fix|Fix|FIX|Revert,%b:^[Cc][Cc]: *<?[Ss]table[@ ]|^[Ff]ixes: *[0-9a-f]"
ABC_DEFAULT_UPSTREAM_LINK="%b:^commit ([0-9a-f]{40})$,%b:^\(cherry picked from commit ([0-9a-f]{40})\)$"
ABC_DEFAULT_NAMESPACE="git-abc"
ABC_DEFAULT_TODO_PATH="git-abc-todo"

# Set parameters per the user's environment or config
: "${ABC_SHOULD_HIGHLIGHT:=$(git config --get abc.should-highlight)}"
: "${ABC_UPSTREAM_LINK:=$(git config --get abc.upstream-link)}"
: "${ABC_NAMESPACE:=$(git config --get abc.namespace)}"
: "${ABC_TODO_PATH:=$(git config --get --type path abc.todo-path)}"
[ -t 1 ] && ABC_COLOR=$(git config --get-colorbool color.ui 'true')

# Set defaults for anything still not set
: "${ABC_SHOULD_HIGHLIGHT:=$ABC_DEFAULT_SHOULD_HIGHLIGHT}"
: "${ABC_UPSTREAM_LINK:=$ABC_DEFAULT_UPSTREAM_LINK}"
: "${ABC_NAMESPACE:=$ABC_DEFAULT_NAMESPACE}"
: "${ABC_TODO_PATH:=$GIT_DIR/$ABC_DEFAULT_TODO_PATH}"
: "${ABC_COLOR:=false}"

die() { echo "$1" >&2; exit 1; }
die_error() { echo "Error: $1" >&2; exit 1; }

get_bool()
{
	git -c abc.not-a-config="$1" config --get --type bool abc.not-a-config 2>/dev/null
	return $?
}

if test -v ABC_HUNT_CHERRIES; then
	if get_bool "$ABC_HUNT_CHERRIES" >&/dev/null; then
		ABC_HUNT_CHERRIES=$(get_bool "$ABC_HUNT_CHERRIES")
	else
		die_error "ABC_HUNT_CHERRIES=$ABC_HUNT_CHERRIES is not boolean"
	fi
elif git config --get --type bool abc.hunt-cherries >&/dev/null; then
	ABC_HUNT_CHERRIES=$(git config --get --type bool abc.hunt-cherries)
elif git config --get abc.hunt-cherries >&/dev/null; then
	die_error "abc.hunt-cherries=$(git config --get abc.hunt-cherries) is not boolean"
else
	ABC_HUNT_CHERRIES="false"
fi

if grep -q '/' <<<"$ABC_NAMESPACE"; then
	die_error "The namespace may not contain '/'"
fi
export GIT_NOTES_REF="refs/notes/$ABC_NAMESPACE"

abc_highlight()
{
	if [ "$ABC_COLOR" = 'true' ]; then
		echo -n -e "\e[33m$1\e[0m"
	else
		echo -n "$1"
	fi
}

# All flags are mutually exclusive, so we always overwrite whatever
# was set before when setting a new one.
abc_set_flag()
{
	local commit=$1 flag=$2
	git notes add -f -m $flag $commit 2>/dev/null
}

abc_is_downstream_only()
{
	local commit=$1
	git notes show $commit 2>/dev/null | grep -q ABC_ONLY_DOWNSTREAM
	return $?
}

abc_import()
{
	local fd flag commit link

	if [ "$1" ]; then
		if [ ! -f "$1" ]; then
			die_error "File '$1' not found"
		fi
		exec {fd}<"$1"
	else
		fd=0
	fi

	while read -r -u $fd flag commit link; do
		case "$flag" in
		BP) abc_set_flag $commit ABC_BACKPORT_PENDING;;
		BC) abc_set_flag $commit ABC_BACKPORT_CANDIDATE;;
		DC) abc_set_flag $commit ABC_DEFERRED_CANDIDATE;;
		DW) abc_set_flag $commit ABC_DONT_WANT;;
		DO) abc_set_flag $commit ABC_ONLY_DOWNSTREAM;;
		US) abc_set_flag $commit "ABC_DOWNSTREAM=$link";;
		DS) abc_set_flag $commit "ABC_UPSTREAM=$link";;
		CP) abc_set_flag $commit "ABC_CHERRYPICK=$link";;
		esac
	done
}

abc_export()
{
	local commit flag

	git notes | awk '{print$2}' |
	while read -r commit; do
		flag=$(git notes show $commit)
		if grep -q ABC_BACKPORT_PENDING <<<$flag; then
			echo "BP $commit"
		elif grep -q ABC_BACKPORT_CANDIDATE <<<$flag; then
			echo "BC $commit"
		elif grep -q ABC_DEFERRED_CANDIDATE <<<$flag; then
			echo "DC $commit"
		elif grep -q ABC_DONT_WANT <<<$flag; then
			echo "DW $commit"
		elif grep -q ABC_ONLY_DOWNSTREAM <<<$flag; then
			echo "DO $commit"
		elif grep -q ABC_DOWNSTREAM <<<$flag; then
			echo "US $commit ${flag#*=}"
		elif grep -q ABC_UPSTREAM <<<$flag; then
			echo "DS $commit ${flag#*=}"
		elif grep -q ABC_CHERRYPICK <<<$flag; then
			echo "CP $commit ${flag#*=}"
		fi
	done
}

abc_reset()
{
	local ans

	if [ "$1" ]; then
		if [ "$1" = '-f' ] || [ "$1" = '--force' ]; then
			ans=yes
		else
			die_error "Unknown option '$1' passed to reset, not resetting"
		fi
	else
		echo "Are you sure you want to erase all backport selection history?"
		read -r -p "If so, type 'yes': " ans
	fi

	if [ "$ans" != 'yes' ]; then
		echo "Not resetting"
		return
	fi

	git notes | awk '{print$2}' | git notes remove --stdin 2>/dev/null
}

abc_get_downstream_revision()
{
	if [ "$ABC_DOWNSTREAM" = "" ]; then
		ABC_DOWNSTREAM=$(git config --get abc.downstream)
	fi

	if [ "$ABC_DOWNSTREAM" = "" ]; then
		ABC_DOWNSTREAM=HEAD
	elif ! git rev-parse --verify -q "$ABC_DOWNSTREAM" >/dev/null; then
		die_error "'$ABC_DOWNSTREAM' is not a valid downstream revision"
	fi
}

abc_get_upstream_revision()
{
	local branch=()

	if [ "$ABC_UPSTREAM" = "" ]; then
		ABC_UPSTREAM=$(git config --get abc.upstream)
	fi

	if [ "$ABC_UPSTREAM" = "" ]; then
		abc_get_downstream_revision
		branch=($(git branch --contains "$ABC_DOWNSTREAM" | sed 's/^\* //'))
		if [ "${branch[1]}" ]; then
			# We don't know which branch to use in our guess, so we can't guess.
			die "Can't guess abc.upstream from abc.downstream $ABC_DOWNSTREAM. Please specify."
		fi
		ABC_UPSTREAM="${branch[0]}@{upstream}"
	fi

	if ! git rev-parse --verify -q "$ABC_UPSTREAM" >/dev/null; then
		die_error "'$ABC_UPSTREAM' is not a valid upstream revision"
	fi
}

abc_get_revisions()
{
	abc_get_upstream_revision
	abc_get_downstream_revision

	if [[ "$(git rev-parse $ABC_UPSTREAM)" == "$(git rev-parse $ABC_DOWNSTREAM)" ]]; then
		die "upstream and downstream cannot be the same reference"
	fi
}

abc_get_limits()
{
	if [[ -n $1 ]] && [[ $1 != -- ]] && git rev-parse --verify -q "$1" >/dev/null; then
		ABC_UPSTREAM=$1
		shift
		if [[ -n $1 ]] && [[ $1 != -- ]] && git rev-parse --verify -q "$1" >/dev/null; then
			ABC_DOWNSTREAM=$1
			shift
		elif [[ $2 == -- ]]; then
			die_error "'$1' is not a valid downstream revision"
		fi
	elif [[ $2 == -- ]] || [[ $3 == -- ]]; then
		die_error "'$1' is not a valid upstream revision"
	fi
	if [[ $1 == -- ]]; then
		shift
	fi
	if [[ -n $1 ]]; then
		ABC_PATHS="$*"
	fi

	abc_get_revisions
}

abc_should_highlight()
{
	local commit=$1
	local phs re

	tr ',%' '\n%' <<<"$ABC_SHOULD_HIGHLIGHT" |
	while IFS=: read -r phs re; do
		if git log -n1 --pretty="$phs" $commit | egrep -q "$re"; then
			return 1
		fi
	done
	test $? -ne 0
}

abc_list()
{
	local range flag commit subject
	local list='--candidates'

	if [[ $1 =~ ^- ]] && [ "$1" != '--' ]; then
		list=$1
		shift
	fi
	abc_get_limits "$@"

	case "$list" in
	--candidates)			range="$ABC_DOWNSTREAM..$ABC_UPSTREAM" flag=ABC_BACKPORT_CANDIDATE;;
	--deferred)			range="$ABC_DOWNSTREAM..$ABC_UPSTREAM" flag=ABC_DEFERRED_CANDIDATE;;
	--pending)			range="$ABC_DOWNSTREAM..$ABC_UPSTREAM" flag=ABC_BACKPORT_PENDING;;
	--rejected)			range="$ABC_DOWNSTREAM..$ABC_UPSTREAM" flag=ABC_DONT_WANT;;
	--backported)			range="$ABC_UPSTREAM..$ABC_DOWNSTREAM" flag='ABC_UPSTREAM\|^ABC_CHERRYPICK';;
	--backported-non-trivial)	range="$ABC_UPSTREAM..$ABC_DOWNSTREAM" flag=ABC_UPSTREAM;;
	--backported-cherry-picks)	range="$ABC_UPSTREAM..$ABC_DOWNSTREAM" flag=ABC_CHERRYPICK;;
	--downstream-only)		range="$ABC_UPSTREAM..$ABC_DOWNSTREAM" flag=ABC_ONLY_DOWNSTREAM;;
	*)
		die_error "Unknown option '$list' passed to list"
		;;
	esac

	git log --notes --pretty='%h %s' --grep=^$flag "$range" |
	while read -r commit subject; do
		if abc_should_highlight $commit; then
			echo "$(abc_highlight $commit) $subject"
		elif [ "$ABC_ONLY_FIXES" != 'y' ]; then
			echo "$commit $subject"
		fi
	done
}

abc_get_patch_id()
{
	local commit=$1
	git show $commit | git patch-id --stable | awk '{print$1}'
}

abc_is_cherry()
{
	local commit_a=$1 commit_b=$2
	local id_a id_b

	id_a=$(abc_get_patch_id $commit_a)
	id_b=$(abc_get_patch_id $commit_b)
	test "$id_a" = "$id_b"
}

abc_set_upstream()
{
	local downstream=$1 upstream=$2 current_upstream

	if [ "$downstream" = "" ] || [ "$upstream" = "" ]; then
		die_error "set-upstream requires two parameters: <downstream-commit> <upstream-commit>"
	fi
	if ! git rev-parse --verify -q "$downstream^{commit}" >/dev/null; then
		die_error "'$downstream' is not a valid commit"
	fi
	if ! git rev-parse --verify -q "$upstream^{commit}" >/dev/null; then
		die_error "'$upstream' is not a valid commit"
	fi
	downstream=$(git log -n1 --pretty=%H $downstream)
	upstream=$(git log -n1 --pretty=%H $upstream)

	current_upstream=$(git notes show $downstream 2>/dev/null | grep -e ABC_UPSTREAM -e ABC_CHERRYPICK)
	if [ "$current_upstream" ]; then
		git notes remove ${current_upstream#*=} 2>/dev/null
	fi

	if abc_is_cherry $downstream $upstream; then
		abc_set_flag $downstream "ABC_CHERRYPICK=$upstream"
	else
		abc_set_flag $downstream "ABC_UPSTREAM=$upstream"
	fi
	abc_set_flag $upstream "ABC_DOWNSTREAM=$downstream"
}

abc_get_upstream_nocheck()
{
	local commit=$1
	local phs re upstream

	upstream=$(git notes show $commit 2>/dev/null | grep -e ABC_UPSTREAM -e ABC_CHERRYPICK)
	if [ "$upstream" ]; then
		echo ${upstream#*=}
		return 1
	fi

	tr ',%' '\n%' <<<"$ABC_UPSTREAM_LINK" |
	while IFS=: read -r phs re; do
		upstream=$(git log -n1 --pretty="$phs" $commit |
				sed -E "s/$re/ABC_UPSTREAM=\1/;/^ABC_UPSTREAM=/!d;s/ABC_UPSTREAM=//")
		if [ "$upstream" ] && git rev-parse --verify -q "$upstream^{commit}" >/dev/null; then
			if [ ${#upstream} -ne 40 ]; then
				git log -n1 --pretty=%H $upstream
			else
				echo $upstream
			fi
			return
		fi
	done
}

abc_get_upstream()
{
	local commit=$1
	local upstream

	if [ "$commit" = "" ]; then
		die_error "get-upstream requires a parameter: <downstream-commit>"
	fi
	if ! git rev-parse --verify -q "$commit^{commit}" >/dev/null; then
		die_error "'$commit' is not a valid commit"
	fi
	if abc_is_downstream_only $commit; then
		die "'$commit' is downstream-only"
	fi

	upstream=$(abc_get_upstream_nocheck $commit)
	if [ "$upstream" ]; then
		git log -n1 --pretty='%h %s' $upstream
		return
	fi

	die "No upstream for '$commit' found"
}

abc_get_downstream()
{
	local commit=$1
	local downstream

	if [ "$commit" = "" ]; then
		die_error "get-downstream requires a parameter: <upstream-commit>"
	fi
	if ! git rev-parse --verify -q "$commit^{commit}" >/dev/null; then
		die_error "'$commit' is not a valid commit"
	fi

	downstream=$(git notes show $commit 2>/dev/null | grep -e ABC_DOWNSTREAM)
	if [ "$downstream" ]; then
		git log -n1 --pretty='%h %s' ${downstream#*=}
		return
	fi

	die "No downstream for '$commit' found"
}

abc_commit_in_range()
{
	declare -a revs
	local commit=$1
	local range=$2

	if [ "$range" ]; then
		revs=($(git rev-parse $range))
		if ! git merge-base --is-ancestor ${revs[1]:1} $commit ||
		   ! git merge-base --is-ancestor $commit ${revs[0]}; then
			return 1
		fi
	fi

	return 0
}

abc_set_links()
{
	local commit=$1
	local upstream_range=$2
	local upstream

	upstream=$(abc_get_upstream_nocheck $commit)
	if [ $? -eq 1 ]; then
		# Move along... we've seen this commit before.
		return
	fi

	if [ "$upstream" = "" ] || ! abc_commit_in_range $upstream $upstream_range; then
		if [ "$ABC_HUNT_CHERRIES" = "true" ]; then
			abc_set_flag $commit ABC_ONLY_DOWNSTREAM_NEW
		else
			abc_set_flag $commit ABC_ONLY_DOWNSTREAM
		fi
		return
	fi

	if abc_is_cherry $commit $upstream; then
		abc_set_flag $commit "ABC_CHERRYPICK=$upstream"
	else
		abc_set_flag $commit "ABC_UPSTREAM=$upstream"
	fi

	abc_set_flag $upstream "ABC_DOWNSTREAM=$commit"
}

abc_list_flag()
{
	local flag=$1
	local commit

	git notes | awk '{print$2}' |
	while read -r commit; do
		if egrep -q "$flag" <<<"$(git notes show $commit)"; then
			echo $commit
		fi
	done
}

# When ABC_HUNT_CHERRIES is true, abc_hunt_cherries() should be called after
# abc_set_links() to ensure all ABC_ONLY_DOWNSTREAM_NEW flags get converted
# to ABC_ONLY_DOWNSTREAM
abc_hunt_cherries()
{
	declare -a new_downstream_only possible_cherries
	declare -A downstream_patchid upstream_patchid
	local commit upstream did uid
	local upstream_range=$1

	# Any new downstream-only commits, that have matching upstream commits, were
	# likely cherry picked from a different upstream tree, which was then later
	# merged to the specified upstream. We can fix up these commits automatically.
	# It's expensive to do, though, so require abc.hunt-cherries to be set true.
	if [ "$ABC_HUNT_CHERRIES" != "true" ]; then
		return
	fi

	for commit in $(abc_list_flag ABC_ONLY_DOWNSTREAM_NEW); do
		abc_set_flag $commit ABC_ONLY_DOWNSTREAM
		new_downstream_only+=($commit)
		downstream_patchid[$commit]=$(abc_get_patch_id $commit)
	done
	if (( ${#new_downstream_only[*]} == 0 )); then
		return
	fi

	possible_cherries=($(abc_list_flag 'ABC_BACKPORT_CANDIDATE|ABC_DEFERRED_CANDIDATE|ABC_BACKPORT_PENDING|ABC_DONT_WANT'))
	if (( ${#possible_cherries[*]} == 0 )); then
		return
	fi

	for commit in ${new_downstream_only[*]}; do
		did=${downstream_patchid[$commit]}
		for upstream in ${possible_cherries[*]}; do
			uid=${upstream_patchid[$upstream]}
			if [ "$uid" = "" ]; then
				upstream_patchid[$upstream]=$(abc_get_patch_id $upstream)
				uid=${upstream_patchid[$upstream]}
			fi
			if [ "$did" = "$uid" ] && abc_commit_in_range $upstream $upstream_range; then
				abc_set_flag $commit "ABC_CHERRYPICK=$upstream"
				abc_set_flag $upstream "ABC_DOWNSTREAM=$commit"
				break
			fi
		done
	done
}

abc_set_upstream_range()
{
	local range=$1
	local upstream_range=$2
	local commit

	if [ "$range" = "" ]; then
		abc_get_limits
		range="$ABC_DOWNSTREAM"..
	fi

	git log --reverse --pretty=%H "$range" | while read -r commit; do
		abc_set_links $commit $upstream_range
		if [ "$ABC_HUNT_CHERRIES" != "true" ] && abc_is_downstream_only $commit; then
			echo "'$(git log -n1 --pretty=%h $commit)' is downstream-only" >&2
		fi
	done

	if [ "$ABC_HUNT_CHERRIES" = "true" ]; then
		abc_hunt_cherries $upstream_range
		git log --reverse --pretty=%H "$range" | while read -r commit; do
			if abc_is_downstream_only $commit; then
				echo "'$(git log -n1 --pretty=%h $commit)' is downstream-only" >&2
			fi
		done
	fi
}

abc_find()
{
	local mark commit parents files

	abc_get_limits "$@"

	git log --parents --pretty='%m %H %P' --left-right \
			"$ABC_UPSTREAM"..."$ABC_DOWNSTREAM" -- $ABC_PATHS |
	while read -r mark commit parents; do
		if [ "$mark" = '>' ]; then
			abc_set_links $commit
		elif ! git notes show $commit 2>/dev/null | grep -q ABC; then
			# If this commit hasn't already been backported, then it's a candidate. However,
			# if $parents has a space it means there's more than one, and more than one
			# parent means a merge. If the merge doesn't have a conflict resolution touching
			# $ABC_PATHS, then we don't want it.
			if [ "$ABC_PATHS" ] && [[ $parents =~ ' ' ]]; then
				files=$(git show --oneline $commit | awk '/^diff --cc / {print$3}' | tr '\n' '|')
				if [ "$files" = "" ] || ! egrep -q "${files%|}" <<<"$ABC_PATHS"; then
					abc_set_flag $commit ABC_DONT_WANT
					continue
				fi
			fi
			abc_set_flag $commit ABC_BACKPORT_CANDIDATE
		fi
	done

	abc_hunt_cherries
}

abc_flag()
{
	local commit curflag
	local flag=$1
	shift

	case "$flag" in
	--pending)	flag=ABC_BACKPORT_PENDING;;
	--candidate)	flag=ABC_BACKPORT_CANDIDATE;;
	--deferred)	flag=ABC_DEFERRED_CANDIDATE;;
	--rejected)	flag=ABC_DONT_WANT;;
	*)
		die_error "Unknown option '$flag' passed to flag"
		;;
	esac
	if [ "$1" = '--' ]; then
		shift
	fi

	for commit in "$@"; do
		if ! git rev-parse --verify -q "$commit^{commit}" >/dev/null; then
			echo "Error: '$commit' is not a valid commit" >&2
			continue
		fi
		curflag=$(git notes show $commit 2>/dev/null)
		if grep -q ABC_DOWNSTREAM <<<$curflag; then
			echo "$commit has already been backported. Downstream is ${curflag#*=}." >&2
			continue
		elif grep -q -e ABC_ONLY_DOWNSTREAM -e ABC_UPSTREAM -e ABC_CHERRYPICK <<<$curflag; then
			echo "$commit is a downstream commit, can't backport." >&2
			continue
		fi
		abc_set_flag $commit $flag
	done
}

git_editor()
{
	local file="$1"
	local editor

	editor=$(git var GIT_EDITOR)
	case "$editor" in
	vim) editor='vim +"setf gitrebase"';;
	esac
	eval "$editor" "$file"
}

abc_select()
{
	local dir commit subject flag cmd i
	local show_deferred show_dropped show_picked
	local cmds=()

	while [ "$1" ]; do
		case "$1" in
		--show-deferred)	show_deferred=y;;
		--show-dropped)		show_dropped=y;;
		--show-picked)		show_picked=y;;
		--show-all)		show_deferred=y show_dropped=y show_picked=y;;
		*)
			break
			;;
		esac
		shift
	done
	abc_get_limits "$@"

	dir=$(dirname "$ABC_TODO_PATH")
	mkdir -p "$dir"

	if [ -e "$ABC_TODO_PATH" ]; then
		die "$ABC_TODO_PATH exists. Complete current selection or remove."
	fi

	git log --notes --pretty='%h %s' --grep=^ABC_ "$ABC_DOWNSTREAM..$ABC_UPSTREAM" |
	while read -r commit subject; do
		flag=$(git notes show $commit)
		if grep -q ABC_BACKPORT_CANDIDATE <<<$flag ||
		   ( [ "$show_deferred" ] && grep -q ABC_DEFERRED_CANDIDATE <<<$flag ); then
			if abc_should_highlight $commit; then
				echo "VIEW $commit $subject" >> "$ABC_TODO_PATH"
			else
				echo "view $commit $subject" >> "$ABC_TODO_PATH"
			fi
		elif [ "$show_dropped" ] && grep -q ABC_DONT_WANT <<<$flag; then
			echo "drop $commit $subject" >> "$ABC_TODO_PATH"
		elif [ "$show_picked" ] && grep -q ABC_BACKPORT_PENDING <<<$flag; then
			echo "pick $commit $subject" >> "$ABC_TODO_PATH"
		fi
	done

	if [ ! -e "$ABC_TODO_PATH" ]; then
		die "No backport candidates found. Have you run git-abc find?"
	fi

	cat<<EOF >>"$ABC_TODO_PATH"

# Select commits for backport
#
# Commands:
# p, pick = commit is accepted for backport
# d, drop = commit is rejected for backport
# c, cand = commit is reset as a candidate
# h, hide = commit is deferred
# s, skip = commit is left as is (i.e. its current flag is not changed)
# v, view = commit is left as is, but it's also selected for viewing
#
# If the view directive is given, then, after viewing, the user is
# prompted for a selection.
#
# If you remove a line here it's the same as setting it to skip.
EOF
	git_editor "$ABC_TODO_PATH"

	mapfile cmds < <(awk '{if (!/^ *#/ && !/^ *$/) print $1" "$2}' "$ABC_TODO_PATH" | tac)
	rm -f "$ABC_TODO_PATH"

	for (( i = 0; i < ${#cmds[*]}; ++i )); do
		read -r cmd commit <<<"${cmds[i]}"
		case "$cmd" in
		P|p|Pick|pick|PICK) abc_flag --pending $commit;;
		D|d|Drop|drop|DROP) abc_flag --rejected $commit;;
		C|c|Cand|cand|CAND) abc_flag --candidate $commit;;
		H|h|Hide|hide|HIDE) abc_flag --deferred $commit;;
		V|v|View|view|VIEW)
			git show $commit
			read -r -p "Backport (Pick/Drop/Cand/Hide/Skip)? " cmd
			while true; do
				case "$cmd" in
				P|p|Pick|pick)
					abc_flag --pending $commit
					break;;
				D|d|Drop|drop)
					abc_flag --rejected $commit
					break;;
				C|c|Cand|cand)
					abc_flag --candidate $commit
					break;;
				H|h|Hide|hide)
					abc_flag --deferred $commit
					break;;
				S|s|Skip|skip)
					break;;
				*)
					read -r -p "Backport (Pick/Drop/Cand/Hide/Skip)? " cmd
					;;
				esac
			done
			;;
		esac
	done
}

abc_get_config()
{
	abc_get_limits "$@"

	printf 'ABC_NAMESPACE=%q\n'		"$ABC_NAMESPACE"
	printf 'ABC_TODO_PATH=%q\n'		"$ABC_TODO_PATH"
	printf 'ABC_SHOULD_HIGHLIGHT=%q\n'	"$ABC_SHOULD_HIGHLIGHT"
	printf 'ABC_UPSTREAM_LINK=%q\n'		"$ABC_UPSTREAM_LINK"
	printf 'ABC_HUNT_CHERRIES=%q\n'		"$ABC_HUNT_CHERRIES"
	printf 'ABC_UPSTREAM=%q\n'		"$ABC_UPSTREAM"
	printf 'ABC_DOWNSTREAM=%q\n'		"$ABC_DOWNSTREAM"
	printf 'ABC_PATHS=%q\n'			"$ABC_PATHS"
}

cmd=$1
shift
case "$cmd" in
find)				abc_find "$@";;
list)				abc_list "$@";;
list-fixes)			ABC_ONLY_FIXES=y abc_list "$@";;
pick-list)			abc_list --pending "$@" | awk '{print$1}' | tac;;
select)				abc_select "$@";;
flag)				abc_flag "$@";;
reject)				abc_flag --rejected "$@";;
accept)				abc_flag --pending "$@";;
defer)				abc_flag --deferred "$@";;
set-upstream)			abc_set_upstream "$@";;
set-upstream-range)		abc_set_upstream_range "$@";;
get-upstream)			abc_get_upstream "$1";;
get-downstream)			abc_get_downstream "$1";;
reset)				abc_reset "$1";;
import)				abc_import "$1";;
export)				abc_export;;
get-config)			abc_get_config "$@";;
*)
	if command -v "git-abc-$cmd" >/dev/null; then
		exec "git-abc-$cmd" "$@"
	else
		echo "$USAGE"
		echo "Try 'git help abc'"
		exit 1
	fi
	;;
esac
