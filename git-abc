#!/bin/bash
#
# git-abc - A Backporter's Companion (ABC)
#           Find and manage backport candidates
#
# Copyright (c) 2017 Red Hat, Inc.
#
# Authors:
#   Andrew Jones <drjones@redhat.com>
#
# This work is licensed under the MIT License. Please see the LICENSE
# file or http://opensource.org/licenses/MIT.
#

# shellcheck disable=SC2034
{
SUBDIRECTORY_OK=true
USAGE="<subcommand> [<options>]"
LONG_USAGE="Find and manage backport candidates

  git abc find [<upstream> [<downstream>]] [[--] <path>...]
  git abc list|list-fixes [<option>] [<upstream> [<downstream>]]
  git abc pick-list [<upstream> [<downstream>]]
  git abc select [<option>] [<upstream> [<downstream>]]
  git abc flag <flag-option> <commit>...
  git abc reject <commit>...
  git abc accept <commit>...
  git abc defer <commit>...
  git abc set-upstream <downstream-commit> <upstream-commit>
  git abc set-upstream-range [<downstream-range>] [<upstream-range>]
  git abc get-upstream <downstream-commit>
  git abc get-downstream <upstream-commit>
  git abc reset [--force]
  git abc import [<file>]
  git abc export
  git abc get-config [<upstream> [<downstream>]] [[--] <path>...]

  See 'git help abc'
"
}
# shellcheck disable=SC1090
. "$(git --exec-path)/git-sh-setup"
set_reflog_action abc

die_error() { echo -n "Error: " >&2; die "$1"; }
warn() { say "Warning: $1" >&2; }

unset abc_merge_base

abc_H() { git log -n1 --pretty=%H "$1"; }
abc_h() { git log -n1 --pretty=%h "$1"; }
abc_rev_verify() { git rev-parse --verify -q "$1" >/dev/null; }
abc_is_ancestor() { git merge-base --is-ancestor "$1" "$2"; } # is "$1" an ancestor of "$2"
abc_commit_in_range() { ! abc_is_ancestor "$1" "$2" && abc_is_ancestor "$1" "$3"; }
abc_patch_id() { local commit=$1 id; read -r id commit <<<"$(git show "$1" | git patch-id --stable)"; echo "$id"; }
abc_is_cherry() { test "$(abc_patch_id "$1")" = "$(abc_patch_id "$2")"; }

#
# Input parsing and validation
#

abc_bool() { git -c abc.not-a-config="$1" config --get --type bool abc.not-a-config 2>/dev/null; }

abc_color="$(abc_bool 'false')"
[ -t 1 ] && abc_color=$(git config --get-colorbool color.ui 'true')

ABC_DEFAULT_SHOULD_HIGHLIGHT="%s:fix|Fix|FIX|Revert,,%b:^[Cc][Cc]: *<?[Ss]table[@ ]|^[Ff]ixes: *[0-9a-f]"
ABC_DEFAULT_UPSTREAM_LINK="%b:^commit ([0-9a-f]{40})$,,%b:^\(cherry picked from commit ([0-9a-f]{40})\)$"
ABC_DEFAULT_NAMESPACE="git-abc"
ABC_DEFAULT_TODO_PATH="$GIT_DIR/git-abc-todo"
ABC_DEFAULT_HUNT_CHERRIES="$(abc_bool 'false')"
ABC_DEFAULT_RANGE_CHECKS="$(abc_bool 'true')"

# Set the parameters that can't / don't need to be validated. Environment overrides git config.
: "${ABC_SHOULD_HIGHLIGHT:=$(git config --get abc.should-highlight)}"
: "${ABC_UPSTREAM_LINK:=$(git config --get abc.upstream-link)}"
: "${ABC_SHOULD_HIGHLIGHT:=$ABC_DEFAULT_SHOULD_HIGHLIGHT}"
: "${ABC_UPSTREAM_LINK:=$ABC_DEFAULT_UPSTREAM_LINK}"

#
# Set and validate input parameters or set defaults for anything not set.
#

abc_set_parameter()
{
	local param_env="$1"
	local defval="$2"
	local param_git="$3"
	local git_config="$4"
	local type="$5"

	unset abc_parameter

	if [ -n "${!param_env}" ]; then
		abc_parameter="$param_env='${!param_env}'"
	elif [ -n "$param_git" ] && $git_config >&/dev/null; then
		eval "$param_env=$($git_config)"
		abc_parameter="$param_git='${!param_env}'"
		if [ "$type" = 'bool' ] && [ -z "${!param_env}" ]; then
			eval "$param_env=$(git config --get --type bool "$param_git")"
			return
		fi
	fi

	if test -v abc_parameter && [ "$type" = 'bool' ]; then
		if ! abc_bool "${!param_env}" >&/dev/null; then
			die_error "$abc_parameter is not boolean"
		else
			eval "$param_env=$(abc_bool "${!param_env}")"
		fi
	elif ! test -v abc_parameter && [ -n "$defval" ]; then
		eval "$param_env=$defval"
		abc_parameter="'$defval'"
	fi
}

abc_set_parameter 'ABC_NAMESPACE' "$ABC_DEFAULT_NAMESPACE" \
		  'abc.namespace' 'git config --get abc.namespace'
if grep -q '/' <<<"$ABC_NAMESPACE"; then
	die_error "$abc_parameter may not contain '/'"
fi

abc_set_parameter 'ABC_TODO_PATH' "$ABC_DEFAULT_TODO_PATH" \
		  'abc.todo-path' 'git config --get --type path abc.todo-path'
if [ -e "$ABC_TODO_PATH" ] && [ ! -d "$ABC_TODO_PATH" ]; then
	die_error "$abc_parameter is not a directory"
fi

abc_set_parameter 'ABC_HUNT_CHERRIES' "$ABC_DEFAULT_HUNT_CHERRIES" \
		  'abc.hunt-cherries' 'git config --get abc.hunt-cherries' \
		  'bool'

abc_set_parameter 'ABC_RANGE_CHECKS' "$ABC_DEFAULT_RANGE_CHECKS" \
		  'abc.range-checks' 'git config --get abc.range-checks' \
		  'bool'

abc_set_revisions()
{
	local upstream=$1 downstream=$2
	local upstream_parameter downstream_parameter
	local branch

	if [[ -z $upstream ]]; then
		abc_set_parameter 'ABC_UPSTREAM' '' \
				  'abc.upstream' 'git config --get abc.upstream'
		if [[ -n $ABC_UPSTREAM ]] && ! abc_rev_verify "$ABC_UPSTREAM"; then
			die_error "$abc_parameter is not a valid revision"
		elif [[ -n $ABC_UPSTREAM ]]; then
			upstream_parameter=$abc_parameter
		fi
	else
		ABC_UPSTREAM="$upstream"
		upstream_parameter="'$upstream'"
	fi

	if [[ -z $downstream ]]; then
		abc_set_parameter 'ABC_DOWNSTREAM' 'HEAD' \
				  'abc.downstream' 'git config --get abc.downstream'
		if ! abc_rev_verify "$ABC_DOWNSTREAM"; then
			die_error "$abc_parameter is not a valid revision"
		fi
		downstream_parameter=$abc_parameter
	else
		ABC_DOWNSTREAM="$downstream"
		downstream_parameter="'$downstream'"
	fi

	if [[ -z $ABC_UPSTREAM ]]; then
		if [[ $(git branch --contains "$ABC_DOWNSTREAM" | wc -l) != 1 ]]; then
			# No branch or too many branches to guess from. We can't guess.
			die "Can't guess upstream from $downstream_parameter. Please specify."
		fi
		branch="$(git branch --contains "$ABC_DOWNSTREAM" | awk '{print$2}')"
		ABC_UPSTREAM="${branch}@{upstream}"
		if ! git rev-parse "$ABC_UPSTREAM" >&/dev/null; then
			die "No upstream configured for branch '$branch' of $downstream_parameter. Please specify."
		fi
	fi

	if [[ "$(git rev-parse "$ABC_UPSTREAM")" == "$(git rev-parse "$ABC_DOWNSTREAM")" ]]; then
		echo "upstream:$upstream_parameter and downstream:$downstream_parameter match. Nothing to do."
		exit
	fi

	if [[ "$(git config --get --type bool core.commitGraph)" == true ]]; then
		abc_merge_base=$(abc_h "$(git merge-base "$ABC_UPSTREAM" "$ABC_DOWNSTREAM")")
	else
		warn "core.commitGraph is not enabled. Disabling commit range checks."
	fi
}

# Validate and set [<upstream> [<downstream>]] [[--] <path>...]
abc_get_limits()
{
	local upstream downstream

	if [[ -n $1 ]] && [[ $1 != -- ]] && abc_rev_verify "$1"; then
		upstream=$1
		shift
		if [[ -n $1 ]] && [[ $1 != -- ]] && abc_rev_verify "$1"; then
			downstream=$1
			shift
		elif [[ $2 == -- ]]; then
			die_error "'$1' is not a valid downstream revision"
		fi
	elif [[ $2 == -- ]] || [[ $3 == -- ]]; then
		die_error "'$1' is not a valid upstream revision"
	fi
	if [[ $1 == -- ]]; then
		shift
	fi
	if [[ -n $1 ]]; then
		ABC_PATHS="$*"
	fi

	abc_set_revisions "$upstream" "$downstream"
}

#
# abc flag functions
#

abc_set_flag()
{
	# All flags are mutually exclusive, so we always overwrite whatever
	# was set before when setting a new one.
	local commit=$1 flag=$2
	git notes add -f -m "$flag" "$commit" 2>/dev/null
}

abc_get_flag() { git notes show "$1" 2>/dev/null; }
abc_is_downstream_only() { git notes show "$1" 2>/dev/null | grep -q ABC_ONLY_DOWNSTREAM; }

abc_flag_get_upstream()
{
	local commit=$1 upstream
	upstream=$(git notes show "$commit" 2>/dev/null | grep -e ABC_UPSTREAM -e ABC_CHERRYPICK)
	if [ "$upstream" ]; then
		echo "${upstream#*=}"
		return 0
	fi
	return 1
}

abc_flag_get_downstream()
{
	local commit=$1 downstream
	downstream=$(git notes show "$commit" 2>/dev/null | grep ABC_DOWNSTREAM)
	if [ "$downstream" ]; then
		echo "${downstream#*=}"
		return 0
	fi
	return 1
}

abc_check_links()
{
	local downstream=$1 upstream=$2 u d

	if u=$(abc_flag_get_upstream "$downstream") && [ "$u" != "$upstream" ]; then
		warn "Overwriting current upstream for '$(abc_h "$downstream")' (upstream was '$(abc_h "$u")')"
	fi

	if d=$(abc_flag_get_downstream "$upstream") && [ "$d" != "$downstream" ]; then
		warn "Overwriting current downstream for '$(abc_h "$upstream")' (downstream was '$(abc_h "$d")')"
	fi
}

abc_link_cherry()
{
	local downstream=$1 upstream=$2

	abc_check_links "$downstream" "$upstream"

	abc_set_flag "$downstream" "ABC_CHERRYPICK=$upstream"
	abc_set_flag "$upstream" "ABC_DOWNSTREAM=$downstream"
}

abc_link()
{
	local downstream=$1 upstream=$2

	abc_check_links "$downstream" "$upstream"

	if abc_is_cherry "$downstream" "$upstream"; then
		abc_set_flag "$downstream" "ABC_CHERRYPICK=$upstream"
	else
		abc_set_flag "$downstream" "ABC_UPSTREAM=$upstream"
	fi

	abc_set_flag "$upstream" "ABC_DOWNSTREAM=$downstream"
}

#
# abc subcommands
#

abc_import()
{
	local fd flag commit link

	if [ "$1" ]; then
		if [ ! -f "$1" ]; then
			die_error "File '$1' not found"
		fi
		exec {fd}<"$1"
	else
		fd=0
	fi

	while read -r -u $fd flag commit link; do
		case "$flag" in
		BP) abc_set_flag "$commit" ABC_BACKPORT_PENDING;;
		BC) abc_set_flag "$commit" ABC_BACKPORT_CANDIDATE;;
		DC) abc_set_flag "$commit" ABC_DEFERRED_CANDIDATE;;
		DW) abc_set_flag "$commit" ABC_DONT_WANT;;
		DO) abc_set_flag "$commit" ABC_ONLY_DOWNSTREAM;;
		US) abc_set_flag "$commit" "ABC_DOWNSTREAM=$link";;
		DS) abc_set_flag "$commit" "ABC_UPSTREAM=$link";;
		CP) abc_set_flag "$commit" "ABC_CHERRYPICK=$link";;
		esac
	done
}

abc_export()
{
	local note commit flag

	git notes | while read -r note commit; do
		flag=$(git show "$note")
		case "$flag" in
		ABC_BACKPORT_PENDING)	echo "BP $commit";;
		ABC_BACKPORT_CANDIDATE)	echo "BC $commit";;
		ABC_DEFERRED_CANDIDATE)	echo "DC $commit";;
		ABC_DONT_WANT)		echo "DW $commit";;
		ABC_ONLY_DOWNSTREAM)	echo "DO $commit";;
		ABC_DOWNSTREAM=*)	echo "US $commit ${flag#*=}";;
		ABC_UPSTREAM=*)		echo "DS $commit ${flag#*=}";;
		ABC_CHERRYPICK=*)	echo "CP $commit ${flag#*=}";;
		esac
	done
}

abc_reset()
{
	local ans

	if [ "$1" ]; then
		if [ "$1" = '-f' ] || [ "$1" = '--force' ]; then
			ans=yes
		else
			die_error "Unknown option '$1' passed to reset, not resetting"
		fi
	else
		echo "Are you sure you want to erase all backport selection history?"
		read -r -p "If so, type 'yes': " ans
	fi

	if [ "$ans" != 'yes' ]; then
		echo "Not resetting"
		return
	fi

	git notes | awk '{print$2}' | git notes remove --stdin 2>/dev/null
}

abc_should_highlight()
{
	local commit=$1 c="${ABC_SHOULD_HIGHLIGHT},,"
	local p phs re

	while [[ "$c" ]]; do
		p="${c%%,,*}" c="${c#*,,}"
		phs="${p%%:*}" re="${p#*:}"
		if git log -n1 --pretty="$phs" "$commit" | grep -E -q "$re"; then
			return 0
		fi
	done
	return 1
}

abc_highlight()
{
	if [ "$abc_color" = 'true' ]; then
		echo -n -e "\e[33m$1\e[0m"
	else
		echo -n "$1"
	fi
}

abc_list()
{
	local range flag commit subject
	local list='--candidates'

	if [[ $1 =~ ^- ]] && [ "$1" != '--' ]; then
		list=$1
		shift
	fi
	abc_get_limits "$@"

	case "$list" in
	--candidates)			range="$ABC_DOWNSTREAM..$ABC_UPSTREAM" flag=ABC_BACKPORT_CANDIDATE;;
	--deferred)			range="$ABC_DOWNSTREAM..$ABC_UPSTREAM" flag=ABC_DEFERRED_CANDIDATE;;
	--pending)			range="$ABC_DOWNSTREAM..$ABC_UPSTREAM" flag=ABC_BACKPORT_PENDING;;
	--rejected)			range="$ABC_DOWNSTREAM..$ABC_UPSTREAM" flag=ABC_DONT_WANT;;
	--backported)			range="$ABC_UPSTREAM..$ABC_DOWNSTREAM" flag='ABC_UPSTREAM\|^ABC_CHERRYPICK';;
	--backported-non-trivial)	range="$ABC_UPSTREAM..$ABC_DOWNSTREAM" flag=ABC_UPSTREAM;;
	--backported-cherry-picks)	range="$ABC_UPSTREAM..$ABC_DOWNSTREAM" flag=ABC_CHERRYPICK;;
	--downstream-only)		range="$ABC_UPSTREAM..$ABC_DOWNSTREAM" flag=ABC_ONLY_DOWNSTREAM;;
	*)
		die_error "Unknown option '$list' passed to list"
		;;
	esac

	git log --notes --pretty='%h %s' --grep=^$flag "$range" |
	while read -r commit subject; do
		if abc_should_highlight "$commit"; then
			echo "$(abc_highlight "$commit") $subject"
		elif [ "$ABC_ONLY_FIXES" != 'y' ]; then
			echo "$commit $subject"
		fi
	done
}

abc_commit_range_check()
{
	local die stream commit range base tip msg

	if [[ $1 == --die ]]; then
		die=1; shift
	fi

	stream=$1 commit=$2 range=$3

	if [[ $range ]]; then
		base="${range%%..*}"
		tip="${range#*..}"
	elif [[ $ABC_RANGE_CHECKS == 'true' && $abc_merge_base ]]; then
		base=$abc_merge_base
		if [[ $stream == upstream ]]; then
			tip=$ABC_UPSTREAM
		else
			tip=$ABC_DOWNSTREAM
		fi
	else
		return
	fi

	if ! abc_commit_in_range "$commit" "$base" "$tip"; then
		msg="'$(abc_h "$commit")' not in $stream range: ${base}..${tip}"
		if [[ $die ]]; then
			die_error "$msg"
		else
			say "$msg" >&2
		fi
	fi
}

abc_set_upstream()
{
	local downstream=$1 upstream=$2 current_upstream

	[[ $downstream && $upstream ]] || die_error "set-upstream requires two parameters: <downstream-commit> <upstream-commit>"
	abc_rev_verify "${downstream}^{commit}" || die_error "'$downstream' is not a valid commit"
	abc_rev_verify "${upstream}^{commit}" || die_error "'$upstream' is not a valid commit"

	abc_set_revisions
	abc_commit_range_check --die 'downstream' "$downstream"
	abc_commit_range_check --die 'upstream' "$upstream"

	abc_link "$(abc_H "$downstream")" "$(abc_H "$upstream")"
}

abc_extract_commit()
{
	# Extract all commit hashes from stdin matching the extended regex
	local re=$1
	sed -E 's/'"$re"'/ABC_XXXXXX=\1/;/^ABC_XXXXXX=/!d;s/ABC_XXXXXX=//'
}

abc_get_upstream_nocheck()
{
	local commit=$1 c="${ABC_UPSTREAM_LINK},,"
	local p phs re upstream
	declare -a matches

	if upstream=$(abc_flag_get_upstream "$commit"); then
		echo "$upstream"
		return 0
	fi

	while [[ "$c" ]]; do
		p="${c%%,,*}" c="${c#*,,}"
		phs="${p%%:*}" re="${p#*:}"

		readarray -t matches < <(git log -n1 --pretty="$phs" "$commit" | abc_extract_commit "$re")

		for upstream in "${matches[@]}"; do
			if abc_rev_verify "${upstream}^{commit}"; then
				upstream=$(abc_H "$upstream")
				abc_link "$(abc_H "$commit")" "$upstream"
				echo "$upstream"
				return 0
			fi
		done
	done

	return 1
}

abc_get_upstream()
{
	local commit=$1 upstream

	[[ $commit ]] || die_error "get-upstream requires a parameter: <downstream-commit>"
	abc_rev_verify "${commit}^{commit}" || die_error "'$commit' is not a valid commit"
	abc_is_downstream_only "$commit" && die "'$commit' is downstream-only"

	abc_set_revisions
	abc_commit_range_check --die 'downstream' "$commit"

	upstream=$(abc_get_upstream_nocheck "$commit") || die "No upstream for '$commit' found"

	abc_commit_range_check 'upstream' "$upstream"

	git log -n1 --pretty='%h %s' "$upstream"
}

abc_get_downstream_nocheck()
{
	local commit=$1 upstream downstream

	if downstream=$(abc_flag_get_downstream "$commit"); then
		echo "$downstream"
		return 0
	fi

	commit=$(abc_H "$commit")
	while read -r downstream; do
		if abc_is_downstream_only "$downstream"; then
			continue
		fi
		if upstream=$(abc_get_upstream_nocheck "$downstream"); then
			if [ "$upstream" = "$commit" ]; then
				echo "$downstream"
				return 0
			fi
		fi
	done < <(git log --pretty=%H --grep "${commit:0:8}" "$ABC_UPSTREAM..$ABC_DOWNSTREAM")

	return 1
}

abc_get_downstream()
{
	local commit=$1 downstream

	[[ $commit ]] || die_error "get-downstream requires a parameter: <upstream-commit>"
	abc_rev_verify "$commit^{commit}" || die_error "'$commit' is not a valid commit"

	abc_set_revisions
	abc_commit_range_check --die 'upstream' "$commit"

	downstream=$(abc_get_downstream_nocheck "$commit") || die "No downstream for '$commit' found"

	abc_commit_range_check 'downstream' "$downstream"

	git log -n1 --pretty='%h %s' "$downstream"
}

abc_set_links()
{
	local commit=$1 upstream_range=$2 upstream

	if upstream=$(abc_get_upstream_nocheck "$commit"); then
		abc_commit_range_check 'upstream' "$upstream" "$upstream_range"
		return
	fi

	if [ "$ABC_HUNT_CHERRIES" = "true" ]; then
		abc_set_flag "$commit" ABC_ONLY_DOWNSTREAM_NEW
	else
		abc_set_flag "$commit" ABC_ONLY_DOWNSTREAM
	fi
}

# When ABC_HUNT_CHERRIES is true, abc_hunt_cherries() should be called after
# abc_set_links() to ensure all ABC_ONLY_DOWNSTREAM_NEW flags get converted
# to ABC_ONLY_DOWNSTREAM
abc_hunt_cherries()
{
	local range=$1 upstream_range=$2 commit upstream did uid
	declare -a new_downstream_only
	declare -A downstream_patchid

	# Any new downstream-only commits, that have matching upstream commits, were
	# likely cherry-picked from a different upstream tree, which was then later
	# merged to the specified upstream. We can fix up these commits automatically.
	# It's expensive to do, though, so require abc.hunt-cherries to be set true.
	if [ "$ABC_HUNT_CHERRIES" != "true" ]; then
		return
	fi

	while read -r commit; do
		abc_set_flag "$commit" ABC_ONLY_DOWNSTREAM
		new_downstream_only+=("$commit")
		downstream_patchid[$commit]=$(abc_patch_id "$commit")
	done < <(git log --notes --pretty=%H --grep '^ABC_ONLY_DOWNSTREAM_NEW' "$range")

	if (( ${#new_downstream_only[@]} == 0 )); then
		return
	fi

	git log --notes --pretty=%H -E --grep '^(ABC_BACKPORT_CANDIDATE|ABC_DEFERRED_CANDIDATE|ABC_BACKPORT_PENDING|ABC_DONT_WANT)' "$upstream_range" |
	while read -r upstream; do
		uid=$(abc_patch_id "$upstream")
		for commit in "${new_downstream_only[@]}"; do
			did=${downstream_patchid[$commit]}
			if [ "$did" = "$uid" ]; then
				abc_link_cherry "$commit" "$upstream"
				break
			fi
		done
	done
}

abc_check_range()
{
	local range=$1
	declare -a revs

	if [[ ! $range =~ \.\. ]]; then
		die "fatal: no .. in range: '$range'"
	elif [[ $range =~ \.\.\. ]]; then
		die "Range ($range) cannot be a symmetric difference (...)"
	elif ! git rev-parse "$range" >&/dev/null; then
		die "'$range' is not a valid"
	fi
}

abc_set_upstream_range()
{
	local range=$1 upstream_range=$2 commit
	local downstream_base downstream_tip upstream_base upstream_tip

	if [[ -z $range ]]; then
		abc_set_revisions
		downstream_base=$ABC_DOWNSTREAM
		downstream_tip='HEAD'
	else
		abc_check_range "$range"
		downstream_base="${range%%..*}"
		downstream_tip="${range#*..}"
	fi

	if [[ -z $upstream_range ]]; then
		if [[ $range ]]; then
			abc_set_revisions
		fi
		if [[ $abc_merge_base ]]; then
			upstream_base=$abc_merge_base
			upstream_tip=$ABC_UPSTREAM
		fi
	else
		abc_check_range "$upstream_range"
		upstream_base="${upstream_range%%..*}"
		upstream_tip="${upstream_range#*..}"

		if [[ "$(git config --get --type bool core.commitGraph)" != true ]]; then
			warn "core.commitGraph is not enabled. Range checking upstream links will be slow."
		fi
	fi

	range="${downstream_base}..${downstream_tip}"

	if [[ $upstream_base ]]; then
		upstream_range="${upstream_base}..${upstream_tip}"
		if abc_commit_in_range "$downstream_base" "$upstream_base" "$upstream_tip" ||
		   abc_commit_in_range "$downstream_tip" "$upstream_base" "$upstream_tip"; then
			die "Downstream range ($range) and upstream range ($upstream_range) overlap"
		fi
	fi

	git log --reverse --pretty=%H "$range" | while read -r commit; do
		abc_set_links "$commit" "$upstream_range"
		if [ "$ABC_HUNT_CHERRIES" != "true" ] && abc_is_downstream_only "$commit"; then
			say "'$(abc_h "$commit")' is downstream-only" >&2
		fi
	done

	if [ "$ABC_HUNT_CHERRIES" = "true" ]; then
		if [[ -z $upstream_range ]]; then
			upstream_range="${ABC_DOWNSTREAM}..${ABC_UPSTREAM}"
		fi
		abc_hunt_cherries "$range" "$upstream_range"
		git log --notes --pretty=%H --reverse "$range" --grep '^ABC_ONLY_DOWNSTREAM' |
		while read -r commit; do
			say "'$(abc_h "$commit")' is downstream-only" >&2
		done
	fi
}

abc_find()
{
	local mark commit parents files

	abc_get_limits "$@"

	git log --parents --pretty='%m %H %P' --left-right \
			"$ABC_UPSTREAM"..."$ABC_DOWNSTREAM" -- $ABC_PATHS |
	while read -r mark commit parents; do
		if [ "$mark" = '>' ]; then
			abc_set_links "$commit"
		elif ! abc_get_flag "$commit" >/dev/null; then
			# If this commit hasn't already been backported, then it's a candidate. However,
			# if $parents has a space it means there's more than one, and more than one
			# parent means a merge. Most merges are clean, or the changes that appear with
			# 'git-show' come directly from one of the parents. Those merges aren't
			# interesting and so we automatically reject them.
			if [[ $parents =~ ' ' ]] && ! git show --pretty=%H "$commit" -- $ABC_PATHS |
						    grep -E -v '^(\+\+\+|---) [ab]\/' | grep -q -E '^(\+\+|--)'; then
				abc_set_flag "$commit" ABC_DONT_WANT
				continue
			fi
			abc_set_flag "$commit" ABC_BACKPORT_CANDIDATE
		fi
	done

	abc_hunt_cherries "${ABC_UPSTREAM}..${ABC_DOWNSTREAM}" "${ABC_DOWNSTREAM}..${ABC_UPSTREAM}"
}

abc_flag()
{
	local flag=$1 commit downstream
	shift

	case "$flag" in
	--pending)	flag=ABC_BACKPORT_PENDING;;
	--candidate)	flag=ABC_BACKPORT_CANDIDATE;;
	--deferred)	flag=ABC_DEFERRED_CANDIDATE;;
	--rejected)	flag=ABC_DONT_WANT;;
	*)
		die_error "Unknown option '$flag' passed to flag"
		;;
	esac
	if [ "$1" = '--' ]; then
		shift
	fi

	abc_set_revisions

	for commit in "$@"; do
		if ! abc_rev_verify "${commit}^{commit}"; then
			echo "Error: '$commit' is not a valid commit" >&2
			continue
		elif [[ $abc_merge_base ]] && ! abc_commit_in_range "$commit" "$abc_merge_base" "$ABC_UPSTREAM"; then
			echo "Error: '$commit' not in upstream range: ${abc_merge_base}..${ABC_UPSTREAM}" >&2
			continue
		fi

		if downstream=$(abc_flag_get_downstream "$commit"); then
			warn "Overwriting current downstream for '$commit' (downstream was '$(abc_h "$downstream")')"
		fi

		abc_set_flag "$commit" "$flag"
	done
}

abc_select()
{
	local todo commit subject flag cmd i
	local show_deferred show_dropped show_picked
	local cmds=()

	while [ "$1" ]; do
		case "$1" in
		--show-deferred)	show_deferred=y;;
		--show-dropped)		show_dropped=y;;
		--show-picked)		show_picked=y;;
		--show-all)		show_deferred=y show_dropped=y show_picked=y;;
		*)
			break
			;;
		esac
		shift
	done
	abc_get_limits "$@"

	mkdir -p "$ABC_TODO_PATH"
	todo="$ABC_TODO_PATH/git-rebase-todo"

	if [ -e "$todo" ]; then
		die "$todo exists. Complete current selection or remove."
	fi

	git log --notes --pretty='%h %s' --grep=^ABC_ "$ABC_DOWNSTREAM..$ABC_UPSTREAM" |
	while read -r commit subject; do
		flag=$(abc_get_flag "$commit")
		if grep -q ABC_BACKPORT_CANDIDATE <<<"$flag" ||
		   ( [ "$show_deferred" ] && grep -q ABC_DEFERRED_CANDIDATE <<<"$flag" ); then
			if abc_should_highlight "$commit"; then
				echo "VIEW $commit $subject" >> "$todo"
			else
				echo "view $commit $subject" >> "$todo"
			fi
		elif [ "$show_dropped" ] && grep -q ABC_DONT_WANT <<<"$flag"; then
			echo "drop $commit $subject" >> "$todo"
		elif [ "$show_picked" ] && grep -q ABC_BACKPORT_PENDING <<<"$flag"; then
			echo "pick $commit $subject" >> "$todo"
		fi
	done

	if [ ! -e "$todo" ]; then
		die "No backport candidates found. Have you run git-abc find?"
	fi

	cat<<EOF >>"$todo"

# Select commits for backport
#
# Commands:
# p, pick = commit is accepted for backport
# d, drop = commit is rejected for backport
# c, cand = commit is reset as a candidate
# h, hide = commit is deferred
# s, skip = commit is left as is (i.e. its current flag is not changed)
# v, view = commit is left as is, but it's also selected for viewing
#
# If the view directive is given, then, after viewing, the user is
# prompted for a selection.
#
# If you remove a line here it's the same as setting it to skip.
EOF
	git_editor "$todo"

	mapfile cmds < <(awk '{if (!/^ *#/ && !/^ *$/) print $1" "$2}' "$todo" | tac)
	rm -f "$todo"
	rmdir --ignore-fail-on-non-empty "$ABC_TODO_PATH"

	for (( i = 0; i < ${#cmds[*]}; ++i )); do
		read -r cmd commit <<<"${cmds[i]}"
		case "$cmd" in
		P|p|Pick|pick|PICK) abc_flag --pending "$commit";;
		D|d|Drop|drop|DROP) abc_flag --rejected "$commit";;
		C|c|Cand|cand|CAND) abc_flag --candidate "$commit";;
		H|h|Hide|hide|HIDE) abc_flag --deferred "$commit";;
		V|v|View|view|VIEW)
			git show "$commit"
			read -r -p "Backport (Pick/Drop/Cand/Hide/Skip)? " cmd
			while true; do
				case "$cmd" in
				P|p|Pick|pick)
					abc_flag --pending "$commit"
					break;;
				D|d|Drop|drop)
					abc_flag --rejected "$commit"
					break;;
				C|c|Cand|cand)
					abc_flag --candidate "$commit"
					break;;
				H|h|Hide|hide)
					abc_flag --deferred "$commit"
					break;;
				S|s|Skip|skip)
					break;;
				*)
					read -r -p "Backport (Pick/Drop/Cand/Hide/Skip)? " cmd
					;;
				esac
			done
			;;
		esac
	done
}

abc_get_config()
{
	abc_get_limits "$@"

	printf 'ABC_NAMESPACE=%q\n'		"$ABC_NAMESPACE"
	printf 'ABC_TODO_PATH=%q\n'		"$ABC_TODO_PATH"
	printf 'ABC_SHOULD_HIGHLIGHT=%q\n'	"$ABC_SHOULD_HIGHLIGHT"
	printf 'ABC_UPSTREAM_LINK=%q\n'		"$ABC_UPSTREAM_LINK"
	printf 'ABC_HUNT_CHERRIES=%q\n'		"$ABC_HUNT_CHERRIES"
	printf 'ABC_RANGE_CHECKS=%q\n'		"$ABC_RANGE_CHECKS"
	printf 'ABC_UPSTREAM=%q\n'		"$ABC_UPSTREAM"
	printf 'ABC_DOWNSTREAM=%q\n'		"$ABC_DOWNSTREAM"
	printf 'ABC_PATHS=%q\n'			"$ABC_PATHS"
}

#
# main
#

export GIT_NOTES_REF="refs/notes/$ABC_NAMESPACE"
cmd=$1
shift
case "$cmd" in
find)				abc_find "$@";;
list)				abc_list "$@";;
list-fixes)			ABC_ONLY_FIXES=y abc_list "$@";;
pick-list)			abc_list --pending "$@" | awk '{print$1}' | tac;;
select)				abc_select "$@";;
flag)				abc_flag "$@";;
reject)				abc_flag --rejected "$@";;
accept)				abc_flag --pending "$@";;
defer)				abc_flag --deferred "$@";;
set-upstream)			abc_set_upstream "$@";;
set-upstream-range)		abc_set_upstream_range "$@";;
get-upstream)			abc_get_upstream "$1";;
get-downstream)			abc_get_downstream "$1";;
reset)				abc_reset "$1";;
import)				abc_import "$1";;
export)				abc_export;;
get-config)			abc_get_config "$@";;
*)
	if command -v "git-abc-$cmd" >/dev/null; then
		exec "git-abc-$cmd" "$@"
	else
		"$0" -h
		exit 1
	fi
	;;
esac
